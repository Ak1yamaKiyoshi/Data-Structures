







#include <iostream> // Бібліотека для вводу та виводу 
#include <cstdlib>  // Бібліотека для генерації випадкових чисел 
#include <ctime>    // Бібліотека для роботи з часом

/// @brief Створює двовимірний масив з випадковими значеннями
/// @param size - кількість рядків у матриці
/// @param size1 - кількість стовпців у матриці
/// @return Вказівник на створений масив
int **createMatrix(int size, int size1) {
    int **matrix = new int *[size]; // Створення нового двовимірного масиву, який буде містити вказівники на рядки матриці.
    for(int i = 0; i < size; i++){ // Початок циклу для ітерації по рядках матриці.
        matrix[i] = new int[size1]; // Створення нового одновимірного масиву в кожному вказівнику рядка матриці.
        for(int j = 0; j < size1; j++) // Занулення значень елементів матриці.
            matrix[i][j] = 0; 
    }
    return matrix; // поветраємо створену матрицю 
}


/// @brief Виводить матрицю на екран
/// @param matrix - вказівник на матрицю
/// @param size - розмір матриці (кількість рядків і стовпців)
void printMatrix(int **matrix, int size){
    for(int i = 0; i < size; i++){   // Початок циклу для ітерації по рядках матриці.
        for(int j = 0; j < size; j++){ // Початок циклу для ітерації по елементах кожного рядка матриці.
            std::cout << matrix[i][j] << " "; // Виводимо елементи матриці через пробіл
        }
        std::cout << std::endl; // Перехід на новий рядок
    }
}


/// @brief Заповнює матрицю випадковими числами від 0 до 75
/// @param matrix - вказівник на матрицю
/// @param size - розмір матриці (кількість рядків і стовпців)
void fillMatrixWithRandom(int **matrix, int size){
    srand(time(0)); // Ініціалізуємо генератор випадкових чисел зі значенням часу
    for(int i = 0; i < size; i++){  
        for(int j = 0; j < size; j++){
            matrix[i][j] = rand() % 76; // Генеруємо випадкове число від 0 до 75 і записуємо в елемент матриці
        }
    }
}


/// @brief Згладжує матрицю шляхом обчислення середнього значення сусідніх елементів
/// @param matrix - вказівник на матрицю
/// @param size - розмір матриці (кількість рядків і стовпців)
/// @return Вказівник на нову матрицю згладжених значень
int **smoothMatrix(int **matrix, int size){
    int **smoothed_matrix = new int *[size];
    // очаток першого циклу, що ітерується по рядках матриці.
    for(int i = 0; i < size; i++){
        /* Створення нового двовимірного масиву smoothed_matrix, який буде містити згладжену матрицю. Він має такий же розмір, як і вхідна матриця. */
        smoothed_matrix[i] = new int[size]; // Виділення пам'яті для кожного стовпця smoothed_matrix для зберігання елементів згладженої матриці.
        /*  Початок другого циклу, що ітерується по стовпцях матриці.*/
        for(int j = 0; j < size; j++){
            int sum_neighbors = 0;  // Змінна для зберігання суми сусідніх елементів 
            int count_neighbors = 0; // Кількість сусідніх елементів 
            
            /* Ці два цикли перебирають всі сусідні рядки та стовпці елемента (i, j). 
            Це означає, що ми розглядаємо кожен елемент, який оточує поточний елемент (i, j).*/
            for(int k = i-1; k <= i+1; k++)
                for(int l = j-1; l <= j+1; l++)
                    /* Умова if перевіряє, чи сусідній елемент (k, l) знаходиться всередині межі матриці. 
                    Це гарантує, що ми не виходимо за межі матриці при доступі до сусідніх елементів. 
                    Умова також перевіряє, що (k, l) не є самим елементом (i, j),
                     оскільки ми хочемо обчислити середнє значення сусідів, а не самого елемента. */
                    if(k >= 0 && k < size && l >= 0 && l < size && (k != i || l != j)){
                        /* арахування суми значень сусідніх елементів matrix[k][l] та підрахунок їх кількості. 
                        Значення сусідів додаються до sum_neighbors, а лічильник count_neighbors збільшується на 1. */
                        sum_neighbors += matrix[k][l];
                        count_neighbors++;
                    }
            /* Після завершення циклів підрахунку сусідів, значення для згладженої матриці smoothed_matrix[i][j] обчислюється, поділивши sum_neighbors на count_neighbors. 
            Це дозволяє отримати середнє значення сусідніх елементів для поточного елемента (i, j).*/
            smoothed_matrix[i][j] = sum_neighbors / count_neighbors;
        }
    }
    
    return smoothed_matrix; // Повертаємо вказівник на злагоджену матрицю
}






